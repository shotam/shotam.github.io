#Integrating Dan's Function for reCoding as numeric variables instead of as FACTORS#
#
# Dan's function to apply the specified contrast to each condition and create a new column for every contrast-level of every condition#
# For each var in varList: if var is a factor, recode; if it's a numeric variable, center#
# Numeric conditions do not need to be factor-ized because they're already factors.#
recode.vars <- function(df, varList, codingFunction, scaleLevelDiffsTo1=F, maxNumLevels=10) {#
  ####
  ###   df:                 REQUIRED argument: The data frame that contains the data to be submitted to the mixed effects model.#
  ####
  ###   varList:            REQUIRED argument: A list of column names in the data frame that contain the variables you want to include in the mixed-effects model.#
  ####
  ###   codingFunction:     REQUIRED argument: A function that will take an integer and return a matrix of variables to use for recoding.#
  ###                                          Examples: contr.sum, contr.treatment, contr.helmert.#
  ####
  ###   scaleLevelDiffsTo1: OPTIONAL argument: If you want the two relevant factor levels in each column to be separated by 1, set this argument to True.#
  ####
  ###   maxNumLevels:       OPTIONAL argument: Don't worry about it unless varList includes a nominal variable with >10 levels; in that case, identify the#
  ###                                          factor in varList that contains the most levels, and set this equal to (at least) that number of levels.#
  ####
  # function to center a continuous variable#
  ct <- function(x) {(scale(as.numeric(x), scale=F))}#
  for (nextVar in varList) {#
    # check to make sure variable is either a factor or is continuous (what else would it be?)#
    if(!is.factor(df[[nextVar]]) & !is.numeric(df[[nextVar]])) { stop("Factor ", nextVar, " is not a factor and is not continuous.") }#
    numLevels = length(names(summary(df[[nextVar]])))#
    # recode if it's a factor variable with 3+ levels#
    if(is.factor(df[[nextVar]])) {#
      # don't execute if there are a ridiculous number of factor levels (unless explicitly passed a parameter allowing that many)#
      #if(is.numeric(maxNumLevels)) { maxNumLevelsCheck = maxNumLevels } else { maxNumLevelsCheck = 10 }#
      if(numLevels > maxNumLevels) {#
        stop(paste("Factor ", nextVar, " has more levels (", numLevels, ") than currently permitted (", maxNumLevels, "). If this is intended, run recode.vars() with maxNumLevels >= ", numLevels, ".", sep=""))#
      }#
      # recode variable using supplied codingFunction#
      recoded.matrix = sapply(df[[nextVar]], function(i) codingFunction( numLevels )[i,])#
      # add each row to the df#
      for (i in seq(numLevels-1)) {#
        if(numLevels > 2) {#
          colToAdd    <- recoded.matrix[i,]#
          nextColName <- paste(nextVar, ".lev", i, sep="")#
        } else {#
          colToAdd    <- recoded.matrix#
          nextColName <- paste(nextVar, ".lev",    sep="")#
        }#
        # check whether level differences should be scaled & scale if so#
        if(scaleLevelDiffsTo1==T) {# & all(c(-1,1) %in% as.numeric(names(summary(as.factor(as.character(colToAdd))))))) {#
          scalingFactor <- max(colToAdd) - min(colToAdd)#
          colToAdd <- colToAdd/scalingFactor#
        }#
        df[[nextColName]] <- colToAdd#
      }#
      # center if it's a numeric/continuous variable#
    } else {#
      df[[paste(nextVar, ".ct", sep="")]] <- ct(df[[nextVar]])#
    }#
  }#
  df#
}#
# Load lmer software#
library(lme4)#
#
#Read Table#
PersynsM = read.table("/Users/gorf/Dropbox/Academics/Revised_Stats/Persyns/Persyns_R.dat", header=T) #
#
PersynsM = recode.vars(Synp1, c("PrimeType", "ExpCond"), contr.sum, scaleLevelDiffsTo1=T) # Sum coding of PrimeType and PrimeCategory using Dan's function
#Read Table#
PersynsM = read.table("/Users/gorf/Dropbox/Academics/Revised_Stats/Persyns/Persyns_R.dat", header=T) #
#
PersynsM = recode.vars(PersynsM, c("PrimeType", "ExpCond"), contr.sum, scaleLevelDiffsTo1=T) # Sum coding of PrimeType and PrimeCategory using Dan's function
print(PersynsM)
# Create full model to compare against:#
PersynsM.full<- glmer(TargBInary ~ PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev#
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = PersynsM, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(PersynsM.full)#
with(PersynsM.full@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)
# Create full model to compare against:#
PersynsM.full<- glmer(TargBinary ~ PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev#
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = PersynsM, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(PersynsM.full)#
with(PersynsM.full@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)
########################
#Test Main Effect of PrimeType#
#
PersynsM.NoPrimeType<- glmer(TargBinary ~ ExpCond.lev + PrimeType.lev:ExpCond.lev#
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = PersynsM, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(PersynsM.NoPrimeType)#
with(PersynsM.NoPrimeType@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)
anova(PersynsM.full, PersysnsM.NoPrimeType)
anova(PersynsM.full, PersynsM.NoPrimeType)
########################
#Test Main Effect of ExpCond               #
PersynsM.NoExpCond<- glmer(TargBinary ~ PrimeType.lev + PrimeType.lev:ExpCond.lev#
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = PersynsM, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(PersynsM.NoExpCond)#
with(PersynsM.NoExpCond@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#
anova(PersynsM.full, PersynsM.NoExpCond)
########################
#Test Interaction Effect of ExpCond:PrimeType#
PersynsM.NoInteraction<- glmer(TargBinary ~ PrimeType.lev + ExpCond.lev #
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = PersynsM, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(PersynsM.NoInteraction)#
with(PersynsM.full@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#
#
anova(PersynsM.full, PersynsM.NoInteraction)
#Integrating Dan's Function for reCoding as numeric variables instead of as FACTORS#
#
# Dan's function to apply the specified contrast to each condition and create a new column for every contrast-level of every condition#
# For each var in varList: if var is a factor, recode; if it's a numeric variable, center#
# Numeric conditions do not need to be factor-ized because they're already factors.#
recode.vars <- function(df, varList, codingFunction, scaleLevelDiffsTo1=F, maxNumLevels=10) {#
  ####
  ###   df:                 REQUIRED argument: The data frame that contains the data to be submitted to the mixed effects model.#
  ####
  ###   varList:            REQUIRED argument: A list of column names in the data frame that contain the variables you want to include in the mixed-effects model.#
  ####
  ###   codingFunction:     REQUIRED argument: A function that will take an integer and return a matrix of variables to use for recoding.#
  ###                                          Examples: contr.sum, contr.treatment, contr.helmert.#
  ####
  ###   scaleLevelDiffsTo1: OPTIONAL argument: If you want the two relevant factor levels in each column to be separated by 1, set this argument to True.#
  ####
  ###   maxNumLevels:       OPTIONAL argument: Don't worry about it unless varList includes a nominal variable with >10 levels; in that case, identify the#
  ###                                          factor in varList that contains the most levels, and set this equal to (at least) that number of levels.#
  ####
  # function to center a continuous variable#
  ct <- function(x) {(scale(as.numeric(x), scale=F))}#
  for (nextVar in varList) {#
    # check to make sure variable is either a factor or is continuous (what else would it be?)#
    if(!is.factor(df[[nextVar]]) & !is.numeric(df[[nextVar]])) { stop("Factor ", nextVar, " is not a factor and is not continuous.") }#
    numLevels = length(names(summary(df[[nextVar]])))#
    # recode if it's a factor variable with 3+ levels#
    if(is.factor(df[[nextVar]])) {#
      # don't execute if there are a ridiculous number of factor levels (unless explicitly passed a parameter allowing that many)#
      #if(is.numeric(maxNumLevels)) { maxNumLevelsCheck = maxNumLevels } else { maxNumLevelsCheck = 10 }#
      if(numLevels > maxNumLevels) {#
        stop(paste("Factor ", nextVar, " has more levels (", numLevels, ") than currently permitted (", maxNumLevels, "). If this is intended, run recode.vars() with maxNumLevels >= ", numLevels, ".", sep=""))#
      }#
      # recode variable using supplied codingFunction#
      recoded.matrix = sapply(df[[nextVar]], function(i) codingFunction( numLevels )[i,])#
      # add each row to the df#
      for (i in seq(numLevels-1)) {#
        if(numLevels > 2) {#
          colToAdd    <- recoded.matrix[i,]#
          nextColName <- paste(nextVar, ".lev", i, sep="")#
        } else {#
          colToAdd    <- recoded.matrix#
          nextColName <- paste(nextVar, ".lev",    sep="")#
        }#
        # check whether level differences should be scaled & scale if so#
        if(scaleLevelDiffsTo1==T) {# & all(c(-1,1) %in% as.numeric(names(summary(as.factor(as.character(colToAdd))))))) {#
          scalingFactor <- max(colToAdd) - min(colToAdd)#
          colToAdd <- colToAdd/scalingFactor#
        }#
        df[[nextColName]] <- colToAdd#
      }#
      # center if it's a numeric/continuous variable#
    } else {#
      df[[paste(nextVar, ".ct", sep="")]] <- ct(df[[nextVar]])#
    }#
  }#
  df#
}#
# Load lmer software#
library(lme4)#
#
#Read Table#
QuadPacts = read.table("/Users/gorf/Dropbox/Academics/Revised_Stats/Quadpacts/Quadpacts_R_no15_79.dat", header=T) #
#
QuadPacts = recode.vars(QuadPacts, c("PrimeType", "ExpCond"), contr.sum, scaleLevelDiffsTo1=T) # Sum coding of PrimeType and ExpCond using Dan's function
# Create full model to compare against:#
PersynsM.full<- glmer(TargBinary ~ PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev#
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = PersynsM, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(PersynsM.full)#
with(PersynsM.full@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)
QuadPacts = read.table("/Users/gorf/Dropbox/Academics/Revised_Stats/Quadpacts/Quadpacts_R_no15_79.dat", header=T) #
#
QuadPacts = recode.vars(QuadPacts, c("PrimeType", "ExpCond"), contr.sum, scaleLevelDiffsTo1=T) # Sum coding of PrimeType and ExpCond using Dan's function#
#
# Create full model to compare against:#
QuadPacts.full<- glmer(TargBinary ~ PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev#
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = QuadPacts, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(QuadPacts.full)#
with(QuadPacts.full@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)
QuadPacts.NoPrimeType<- glmer(TargBinary ~ ExpCond.lev + PrimeType.lev:ExpCond.lev#
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = QuadPacts, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(QuadPacts.NoPrimeType)#
with(QuadPacts.NoPrimeType@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#
anova(QuadPacts.full, QuadPacts.NoPrimeType)
#Test Main Effect of ExpCond   #
QuadPacts.NoExpCond<- glmer(TargBinary ~ PrimeType.lev + PrimeType.lev:ExpCond.lev#
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = QuadPacts, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(QuadPacts.NoExpCond)#
with(QuadPacts.NoExpCond@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#
anova(QuadPacts.full, QuadPacts.NoExpCond)
#Test Interaction Effect of ExpCond:PrimeType#
QuadPacts.NoInteraction<- glmer(TargBinary ~ PrimeType.lev + ExpCond.lev #
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = QuadPacts, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(QuadPacts.NoInteraction)#
with(QuadPacts.full@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#
#
anova(QuadPacts.full, QuadPacts.NoInteraction)        #
#####ANOVA RESULTS
QuadPacts = read.table("/Users/gorf/Dropbox/Academics/Revised_Stats/Quadpacts/Quadpacts_R_all_subjects.dat", header=T)
QuadPacts = recode.vars(QuadPacts, c("PrimeType", "ExpCond"), contr.sum, scaleLevelDiffsTo1=T) # Sum coding of PrimeType and ExpCond using Dan's function#
#
# Create full model to compare against:#
QuadPacts.full<- glmer(TargBinary ~ PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev#
                       + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Subject) + (1 + PrimeType.lev + ExpCond.lev + PrimeType.lev:ExpCond.lev || Trial)#
                       , data = QuadPacts, family = binomial, verbose=T, control=glmerControl(optimizer="bobyqa"))#
summary(QuadPacts.full)#
with(QuadPacts.full@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)
#Read File into variable#
QuadpactsD = read.table("/Users/gorf/Dropbox/Academics/R_analyses/Quadpacts/Quadpacts_R.dat", header=T)
#Read File without 15/79 (anyone with less than 50% data)#
QuadpactsD = read.table("/Users/gorf/Dropbox/Academics/R_analyses/Quadpacts/Quadpacts_R_no15_79.dat", header=T)
#First I'm gonna do the SUM coding#
QuadpactsD$PrimeType.f = factor(QuadpactsD$PrimeType, labels=c("preferred", "dispreferred"))#
contrasts(QuadpactsD$PrimeType.f) = contr.sum(2)#
QuadpactsD$ExpCond.f = factor(QuadpactsD$ExpCond, labels=c("Same", "Different"))#
contrasts(QuadpactsD$ExpCond.f) = contr.sum(2)
#Test for Main Effect#
QuadpactsD.full<- glmer(TargBinary ~ PrimeType.f + ExpCond.f + (1 + PrimeType.f + ExpCond.f|Subject) + (1 + PrimeType.f + ExpCond.f|Trial), family=binomial, data = QuadpactsD, control=glmerControl(optimizer="bobyqa"))#
summary(QuadpactsD.full)#
with(QuadpactsD.full@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)
#Model Comparison for Experimenter Effect#
QuadpactsD.full<- glmer(TargBinary ~ PrimeType.f + ExpCond.f + PrimeType.f*ExpCond.f + (1 + PrimeType.f*ExpCond.f|Subject) + (1 + PrimeType.f*ExpCond.f|Trial), family=binomial, data = QuadpactsD, control=glmerControl(optimizer="bobyqa"))#
summary(QuadpactsD.full)#
with(QuadpactsD.full@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)
